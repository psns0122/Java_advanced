## [자바 자료구조 - 컬렉션]

* Collection 인터페이스의 최상위 인터페이스 Iterable (이터레이블)
- default void forEach(Consumer<? super T> action) : 함수형 프로그래밍 전용 루프 메소드
- Iterator <T> iterator() : 컬렉션에서 이터레이터를 구현
- default Spliterator <T> Spliterator() : 파이프라이닝(연결) 관련 메소드

* Map 인터페이스는 **Iterable 인터페이스를 상속받지 않음** -> 따라서 **Stream을 사용하거나, 간접적으로 키를 Collection으로 변환하여 루프문을 순회** 하는 방식을 사용.

* 결론 : **Iterable은 List, Set, Queue에 상속을 하는 실질적인 최상위 컬렉션 타입**, upcasting으로 다양한 종류의 컬렉션 자료형을 받아 데이터를 삽입, 삭제, 탐색 기능을 처리할 수 있다.

## [Comparable Interface / Comparator]
* Comparable Iterface를 구현한 클래스는 compareTo() 메소드를 오버라이딩해서 구현 클래스 객체들 간의 정렬 기준을 지정할 수 있다.
* 리스트 : Collection.sort()
* 배열 : Array.sort()

    * Comparable Interface : 미리 기준을 정할 때 (컴페얼어블)
    * Comparator : 그때 그때 기준을 세울 때       ()

```java
// 정렬의 패턴
// 1. compare로 정렬 기준 설정 2. 정렬 실행 3. 출력

//return 값이 양수면 자리교환 ,  0 이거나 음수면 자리교환 없음
// Comparable 인터페이스를 구현하여 정렬 기준 설정 (나이 오름차순 정렬)
@Override
public int compareTo(User o) {
    return this.age - o.age; // 양수면 자리 교환, 0 또는 음수면 자리 유지
}

// 리스트 요소 출력 (forEach 사용)
users.forEach(System.out::println); // 컬렉션 사용
users.stream().sorted().forEach(System.out::println); // 스트림 사용

// 람다를 사용하여 정렬 기준 설정 (나이 오름차순)
users.sort((o1, o2) -> o1.age - o2.age);

// 익명 클래스를 사용하여 정렬 기준 설정
Collections.sort(users, new Comparator<User>() {
    @Override
    public int compare(User o1, User o2) {
        return Integer.compare(o1.age, o2.age); // 나이 기준 정렬
        // return o1.name.compareTo(o2.name); // 이름 기준 정렬
    }
});

// 람다를 사용한 간결한 정렬 (나이 기준 오름차순)
Collections.sort(users, (u1, u2) -> Integer.compare(u1.age, u2.age));

// private 필드 접근 시 Comparator.comparing() 사용
Collections.sort(users, Comparator.comparing(User::getAge)); // 나이 기준 정렬
Collections.sort(users, Comparator.comparing(User::getAge).thenComparing(User::getName)); // 나이 -> 이름 순 정렬
		
```